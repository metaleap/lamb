
/*  atoms: float int tags
    composite:
        tagged foo
        sequence of foo
            n-ary tuple: fixed-length any-typed sequence
            string: tagged list of int32
        sets:
            unary: set of foo
            binary: relations or maybe map or maybe record
            n-ary: set of n-ary-tuple relations
*/

/*
t list          :=  _   | Link                  ? True
                        | Link: (_foo & _rest)  ? foo t && rest (t list)
*/


val must cmp:[yo] arg :=
    val cmp arg | True  ? val // no comment
                | False ? Err: msg="must on $T$val not satisfied: $check $cmp $arg"


list yo:yo first:ok _rue,list must /= Empty :=
    list | Link: (_f & _) ? f


list rest :=
    list    | Link: (_ & r)     ? r
            | Empty             ? Err: msg="rest: list must not be Empty"


x pow y :=
    y < 0   | True  ? 1.0 / (x pow y.neg)
            | False ? *x from 1 To y

f "from" _initial "or" from 1 To 'n' :=
    True    | n==0  ? initial
            |       ? f from initial To n-1 f

/*  eg.     x pow 3 evaluates already statically to:
        = (*x from 1 To 3)
        = (*x from 1 To 2) *x
        = (*x from 1 To 1) *x *x
        = (*x from 1 To 0) *x *x *x
        = 1 *x *x *x
        = x *x *x
*/



a × b , a must < 0, foo >= "1.23" :=
    a == 0  | True  ? Link
            | False ? Link: b & a-1×b
            | True  ? wot is dis

    foo:bool ret moo:yo bla := Link: ("foo" & ab)
    ab      := 'a'-1 × 3*-b, xret := foo

x := b

someRec :=
    Name: (First: "Phil" & Last: "Shoeman") & Age: 37
    // { Name: { First: "Phil", Last: "Schumann" }, Age: 37 }


f _accumR 10 "initial" _list :=
    list    | Empty                     ? initial
            | Link: (_first & _rest)    ? first 'f' (f accumR initial rest)


f:int _accumL initial list :=
    list    | Link                      ? initial, unused := 123
            | Link: (_first & _rest)    ? f accumL (initial f first) rest
    f:oo unless := foo if True 0 False 1
