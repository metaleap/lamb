
ptrIncr := /define {} /P { #ptr: /P, #incr_by: /I } {
  #: [
    /let { #ptr_as_int: /convert /I (/P #ptr) },
    /let { #ptr_int_incr: /op2 #add /I #incr_by #ptr_as_int },
    /let { #int_as_ptr: /convert /P (/I #ptr_int_incr) },
    /ret (/P #int_as_ptr),
  ],
}

swapByte := /define {} /V { #ptr_l: /P, #ptr_r: /P } {
  #: [
    /let { #byte_l: /load /I8 #ptr_l },
    /let { #byte_r: /load /I8 #ptr_r },
    /store #ptr_l (/I8 #byte_r),
    /store #ptr_r (/I8 #byte_l),
    /ret,
  ],
}

reverse := /define {} /V { #buf: /P, #len: /I } {
    #begin: [
      /let { #is0: /icmp #eq /I #len 0 },
      /let { #len_half: /op2 #udiv /I #len 2 },
      /let { #i_last: /op2 #sub /I #len 1 },
      /brIf #is0 #end #loop,
    ],
    #loop: [
      /let { #i: /phi /I { #begin: 0, #loop: #i_next } },
      /let { #i_swap: /op2 #sub /I #i_last #i },

      /let { #ptr_l: /call /@ptrIncr /P [/P #buf, /I #i] },
      /let { #ptr_r: /call /@ptrIncr /P [/P #buf, /I #i_swap] },
      /call /@swapByte /V [/P #ptr_l, /P #ptr_r],

      /let { #i_next: /op2 #add /I #i 1 },
      /let { #loop_again: /icmp #ult /I #i_next #len_half },
      /brIf #loop_again #loop #end,
    ],
    #end: [
      /ret,
    ],
}

main := /define {} /I32 {} {
  #: [
    /let { #buf: /alloca /I8 (/I32 1024) },
    /let { #n: /call /@readInOrDie /I [/P #buf, /I 1024] },
    /call /@reverse /V [/P #buf, /I #n],
    /call /@writeOut /V [/P #buf, /I #n],
    /ret (/I32 0),
  ],
}
