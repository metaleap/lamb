
writeTo := /define {} /I16 { #str_ptr: /P, #str_len: /I, #out_file: /P } {
  #begin: [
    /let { #n : /call {} /@libcFWrite /I [/P #str_ptr, /I 1, /I #str_len, /P #out_file] },
    /let { #ok: /icmp #eq /I #n #str_len },
    /brIf #ok #end #err_case,
  ],
  #err_case: [
      /let { #err_code: /call {} /@libcFError /I16 [/P #out_file] },
      /brTo #end,
  ],
  #end: [
    /let { #ret_val: /phi {} /I16 { #begin: 0, #err_case: #err_code } },
    /ret (/I16 #ret_val),
  ]
}


writeToStd := /define {} /V { #str_ptr: /P, #str_len: /I, #std_file: /P/P } {
  #begin: [
    /let { #out_file: /load {} /P (/P/P #std_file) },
    /let { #err: /call {} /@writeTo /I16 [/P #str_ptr, /I #str_len, /P #out_file] },
    /switch (/I16 #err) #end { /I16 1: #exit_on_err },
  ],
  #exit_on_err: [
    /call {} /@libcExit /V [/I16 1], // TODO noreturn annotation
    /unreachable,
  ],
  #end: [
    /ret (/V #),
  ],
}


writeErr := /define {} /V { #str_ptr: /P, #str_len: /I } {
  #: [
    /call {} /@writeToStd /V [/P #str_ptr, /I #str_len, /P/P /@libc_stderr],
    /ret (/V #),
  ],
}


writeOut := /define {} /V { #str_ptr: /P, #str_len: /I } {
  #: [
    /call {} /@writeToStd /V [/P #str_ptr, /I #str_len, /P/P /@libc_stdout],
    /ret (/V #),
  ],
}

readFrom := /define {} /I { #buf_ptr: /P, #buf_len: /I, #in_file: /P } {
  #: [
    /let { #n: /call {} /@libcFRead /I [/P #buf_ptr, /I 1, /I #buf_len, /P #in_file] },
    /ret (/I #n),
  ],
}

readInOrDie := /define {} /I { #buf_ptr: /P, #buf_len: /I } {
  #begin: [
    /let { #in_file: /load {} /P (/P/P /@libc_stdin) },
    /let { #n: /call {} /@readFrom /I [/P #buf_ptr, /I #buf_len, /P #in_file] },
    /let { #err: /call {} /@libcFError /I16 [/P #in_file] },
    /let { #ok: /icmp #eq /I16 #err 0 },
    /brIf #ok #end #die,
  ],
  #die: [
    /call {} /@libcExit /V [/I16 1], // TODO noreturn annotation
    /unreachable,
  ],
  #end: [
    /let { #n_ok: /phi {} /I { #begin: #n } },
    /ret (/I #n_ok),
  ],
}
